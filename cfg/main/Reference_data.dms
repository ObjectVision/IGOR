Container Reference_data
: Using = "SourceData/RegionalUnits;SourceData"
, Descr = "Procedures to generate reference 2011 base maps per narrow age class, with LAU2 census data, SEDAC grids, and additional local data for NL, SK and SI" 
{
	parameter<uint8>    NumberOfIterations        := 10b,           Descr = "Number of iterations for balancing assignment.";
	parameter<float32>  ε                         := 0.00001f;

	attribute<Person>  Ardeco           (p) := Population/Ardeco/data;
	attribute<Person>  ESTAT_M          (e) := max_elem(Population/ESTAT_Male/data  , ε);
	attribute<Person>  ESTAT_F          (e) := max_elem(Population/ESTAT_Female/data, ε);
	attribute<Person>  ESTAT_LT15       (e) := max_elem(Population/ESTAT_LT15/data  , ε);
	attribute<Person>  ESTAT_15_64      (e) := max_elem(Population/ESTAT_15_64/data , ε);
	attribute<Person>  ESTAT_GE65       (e) := max_elem(Population/ESTAT_GE65/data  , ε);
	
	attribute<Person>  ESTAT_Total_Sex  (e) := ESTAT_M + ESTAT_F;
	attribute<Person>  ESTAT_Total_Age  (e) := ESTAT_LT15 + ESTAT_15_64 + ESTAT_GE65;

	attribute<Share>   Share_M          (e) := MakeDefined(ESTAT_M   / ESTAT_Total_Sex, 1f)[Share];
	attribute<Share>   Share_F          (e) := 1f - Share_M;
	attribute<Share>   Share_LT15       (e) := (ESTAT_LT15   / ESTAT_Total_Age)[Share];
	attribute<Share>   Share_15_64      (e) := (ESTAT_15_64  / ESTAT_Total_Age)[Share];
	attribute<Share>   Share_GE65       (e) := (ESTAT_GE65   / ESTAT_Total_Age)[Share];
	
	
	container Checks
	{
		attribute<bool>     ESTAT_Sex_0_and_with_ARDECO_pop (e) := ESTAT_Total_Sex < 1f && P_e > 0f;
		attribute<bool>     ESTAT_Age_0_and_with_ARDECO_pop (e) := ESTAT_Total_Age < 1f && P_e > 0f;
		
		attribute<Share>    Share_M_LAU                     (r) := (sum(Population/AGEGROUP5_SEX_perLAU/result/SexClass_rel == Sex/v/M ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total)[Share];
		attribute<Share>    Share_F_LAU                     (r) := 1f - Share_M_LAU;
		attribute<Share>    Share_LT15_LAU                  (r) := (sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/LT15 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total)[Share];
		attribute<Share>    Share_15_64_LAU                 (r) := (sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/_15_64 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total)[Share];
		attribute<Share>    Share_GE65_LAU                  (r) := (sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/GE65 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total)[Share];
	
		attribute<Person>   P_r                             (r) := sum(P_i, i/r_rel); //debug
		// attribute<Person>   Diff_Q_and_P                    (r) := Q_asr_Raw/total -  P_r; //debug
		// attribute<Person>   Diff_Q_and_P_ifany0             (r) := Q_asr_Raw/total == 0f || P_r == 0f ? Diff_Q_and_P : 0f; //debug
		
		attribute<bool>     Qr_0_and_Pr_gt0                 (r) := impl/Q_asr_Raw/total == 0f && P_r > 0f; //issue #12
	}
	
	container Impl
	{
		unit<UInt8> Iter := cat_range(1b, NumberOfIterations + 1b)
		{
			attribute<String> name        := 'Iter_'+string(id(.));
			attribute<Bool>   IsFirstIter := id(.) == 1b;
			attribute<String> PrevName    := IsFirstIter ? 'Iter_0' : name[id(.) - min_elem( id(.), 1b)];
			attribute<String> Label       := name;
		}
	
		container Q_asr_shares_based_on_NUTS3 := 
			for_each_nedv(
				SexAgeClasses/name
				, '((sum(Q_asr_Raw/'+SexAgeClasses/name+', r/NUTS3_rel) /  sum(Q_asr_Raw/total, r/NUTS3_rel))[Share])[r/NUTS3_rel]'
				, r
				, Share
			), Descr = "Population per LAU region, split per SexAgeGroup";
		
		// container Q_s_shares := 
			// for_each_nedv(
				// Sex/name
				// , '('+AsList('Q_asr/'+SexAgeClasses/name,'+', SexAgeClasses/first_rel)+') / Q_asr/total'
				// , r
				// , Share
			// );
		
		// container Q_b_shares := 
			// for_each_nedv(
				// BroadClasses/name
				// , '('+AsList('Q_asr/'+SexAgeClasses/name,'+', SexAgeClasses/BroadClasses_rel)+') / Q_asr/total'
				// , r
				// , Share
			// );
			
		container Q_asr_RAW := 
			for_each_nedv(
				SexAgeClasses/name
				, 'sum(Population/AGEGROUP5_SEX_perLAU/result/SexAgeClass_rel == SexAgeClasses/v/'+SexAgeClasses/name+' ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel)'
				, r
				, Person
			), Descr = "Population per LAU region, split per SexAgeGroup"
		{
			attribute<Person>  Total  (r) := = 'add('+AsItemList(SexAgeClasses/name)+')';
		}
	}
	
	unit<ipoint>        p                      := domain_100m, Descr = "possible domain of population maps"
	{
		attribute<i> i_rel := p/domain_rel;
	}
	unit<ipoint>        e                      := domain_1000m, Descr = "domain of ESTAT population characterisation";
	
	unit<uint32>        i                      := domain, Descr ="domain for which IPF is done, an grouping of p, and relating to r and e"
	{
		attribute<r> r_rel := domain/r_rel_in_sa;
		attribute<e> e_rel := domain/domain_1000m_rel;
	}
	
	unit<uint32>        r                      := LAU, Descr = "domain of LAU population pyramid data"
	{
		attribute<.> per_p (p) := per_domain_100m;
		attribute<.> per_i (i) := i/r_rel;
	}
	
	attribute<Person>   P_p                (p) := Ardeco, Descr = "Population per 100m gridcell i, based on ARDECO dataset";
	attribute<Person>   P_i                (i) := sum(P_p, p/i_rel), Descr = "Population aggregated form 100m gridcell, per IPF unit";
	attribute<Person>   P_e                (e) := sum(P_i, i/e_rel), Descr = "Population per 1km block, based on ARDECO dataset and study area";
	attribute<Person>   P_ee               (e) := sum(P_p, mapping(p, e)), Descr = "Population per 1km block, based on ARDECO dataset without considering LAU regions and study area";
	attribute<Person>   delta_P            (e) := P_ee - P_e;
	
	container E_ib := 
		for_each_nedv(
			BroadClasses/name
			, 'Checks/ESTAT_Age_0_and_with_ARDECO_pop[i/e_rel] ? Checks/Share_'+BroadClasses/label+'_LAU[r/per_i] : Share_'+BroadClasses/label+'[i/e_rel]'
			, i
			, Share
		), Descr = "Population per 1 km gridcell i, per BroadAgeGroup, based on ESTAT dataset" 
	{
		attribute<Share>  Total  (domain) := = 'add('+AsItemList(BroadClasses/name)+')';
	}
		
	container E_is := 
		for_each_nedv(
			Sex/name
			, 'Checks/ESTAT_Sex_0_and_with_ARDECO_pop[i/e_rel] ? Checks/Share_'+Sex/name+'_LAU[r/per_i] : Share_'+Sex/name+'[i/e_rel]'
			, i
			, Share
		), Descr = "Population per 1 km gridcell i, per sex, based on ESTAT dataset" 
	{
		attribute<Share>  Total  (domain) := = 'add('+AsItemList(Sex/name)+')';
	}
		
	container Q_asr := 
		for_each_nedv(
			SexAgeClasses/name
			, 'Checks/Qr_0_and_Pr_gt0 ? Checks/P_r * impl/Q_asr_shares_based_on_NUTS3/'+SexAgeClasses/name+' : impl/Q_asr_RAW/'+SexAgeClasses/name+''
			, r
			, Person
		), Descr = "Population per LAU region, split per SexAgeGroup"
	{
		attribute<Person>  Total  (r) := = 'add('+AsItemList(SexAgeClasses/name)+')';
	}
	
	
	container Iters :=
		for_each_ne(
			Impl/Iter/name
			,'Iter_T('+quote(Impl/Iter/PrevName)+')'
		), Descr = ""
	{
		container Iter_0
		{
			container B_asr := 
				for_each_nedv(
					SexAgeClasses/name
					, 'const(1f, r)'
					, r
					, float32
				), Descr = "balancing factor SexAgeGroup in region r";
		}
	}
	
	container Result := ='Iters/'+last(Impl/Iter/name)
	{
		container X_asr := 
			for_each_nedv(
				SexAgeClasses/name
				, 'sum(X_asi/'+SexAgeClasses/name+', i/r_rel)'
				, r
				, Person
			), Descr = "population per SexAgeGroup per cell summed per region."
		{
			attribute<Person>  Total  (r) := = 'add('+AsItemList(SexAgeClasses/name)+')';
		}
			
		container Diff_X_asr_Q_asr := 
			for_each_nedv(
				SexAgeClasses/name
				, 'X_asr/'+SexAgeClasses/name+' - Q_asr/'+SexAgeClasses/name+ ' * (sum(X_asi/Total, i/r_rel) / Q_asr/Total)'
				, r
				, Person
			);
			
		attribute<Person> Diff_X_i_P_i (i) := X_asi/Total - P_i, Descr = "difference between output summed pop per grid cell and input total pop.";
		
		attribute<float32>  MAPE (r) := 100f * (1f / count(X_asi/Total,  i/r_rel)[float32]) * sum( abs(P_i - X_asi/Total) / P_i,  i/r_rel), Descr = "Mean Absolute Percentage Error: a measure used to evaluate the accuracy of a forecasting model. It expresses the accuracy as a percentage. Interpretation: Lower MAPE: Indicates a better fitting model, as the errors are smaller in comparison to the actual values. Higher MAPE: Suggests a less accurate model, with larger errors relative to the actual values.";
		
		container Error_Distr_vs_Expected_Shares := 
			for_each_nedv(
				SexAgeClasses/name
				, 'MakeDefined(abs(sum(X_asi/'+SexAgeClasses/name+' , i/r_rel) / sum(X_asi/Total, i/r_rel) - Q_asr/'+SexAgeClasses/name+' / Q_asr/Total), sum(X_asi/Total, i/r_rel) == 0f && Q_asr/Total == 0f ? 0f : 99f)'
				, r
				, Share
			), Descr = "Error in distributed vs expected population shares"
		{
			attribute<Share>         MinElem (r) := ='min_elem('+AsItemList(SexAgeClasses/name)+')';
			attribute<SexAgeClasses> ArgMin  (r) := ='ArgMin('+AsItemList(SexAgeClasses/name)+')';
			attribute<Share>         MaxElem (r) := ='max_elem('+AsItemList(SexAgeClasses/name)+')';
			attribute<SexAgeClasses> ArgMax  (r) := ='ArgMax('+AsItemList(SexAgeClasses/name)+')';
		}
			
		container Error_Abs_vs_Expected_Sizes := 
			for_each_nedv(
				SexAgeClasses/name
				, 'abs(sum(X_asi/'+SexAgeClasses/name+' , i/r_rel) - Q_asr/'+SexAgeClasses/name+')'
				, r
				, Person
			), Descr = "Error in absolute vs expected population sizes";
	}
	

	Template Iter_T
	{
		parameter<string> PrevIterName;
		container PrevIter := =PrevIterName;
		///
		
		attribute<float32> A_i_raw (i) := ='P_i / ('+AsList('E_is/'+SexAgeClasses/Sex_rel -> name+' 
												* E_ib/'+SexAgeClasses/BroadClasses_rel -> name+' 
												* PrevIter/B_asr/'+SexAgeClasses/name+'[i/r_rel]', '+')+')'
											, Descr = "balancing factor, totale populatie in cell i. Which means that it, ceteris paribus, scales with population density"; 
		attribute<float32> A_i     (i) := MakeDefined(A_i_raw, 0f);
		
		container X_asi := 
			for_each_nedv(
				SexAgeClasses/name
				, 'E_is/'+SexAgeClasses/Sex_rel -> name+' * E_ib/'+SexAgeClasses/BroadClasses_rel -> name+' * A_i * PrevIter/B_asr/'+SexAgeClasses/name+'[i/r_rel]'
				, i
				, Person
			), Descr = "resulting population per SexAgeGroup in cell i (rebalanced by A_i from this iteration)"
		{
			attribute<Person> Total (i) := =AsList('X_asi/'+SexAgeClasses/name, '+'),
				Descr = "Sum of population per SexAgeGroup (rebalanced with A_i from this iteration); item not used in computations: debug purposes";
		}
		
		//intuition:
			// if X_asr > Q_asr -> B_asr smaller
			// if X_asr < Q_asr -> B_asr larger
			// if X_asr ~= 0 and Q_asr > 0 -> B_asr towards infinity
			
		container B_asr_raw := 
			for_each_nedv(
				SexAgeClasses/name
				, 'MakeDefined(PrevIter/B_asr/'+SexAgeClasses/name+' * Q_asr/'+SexAgeClasses/name+' / sum(X_asi/'+SexAgeClasses/name+', i/r_rel), 0f)'
				, r
				, float32
			), Descr = "Recalculated balancing factor SexAgeGroup in region r, used in next iteration"
		{
			attribute<float32> Total      (r) := =AsList(''+SexAgeClasses/name, '+');
			attribute<float32> Max_elem   (r) := ='max_elem('+AsList(''+SexAgeClasses/name, ',')+', ε)';
		}
		container B_asr := 
			for_each_nedv(
				SexAgeClasses/name
				, 'B_asr_raw/'+SexAgeClasses/name + ' / B_asr_raw/Max_elem'
				, r
				, float32
			), Descr = "Recalculated balancing factor SexAgeGroup in region r, used in next iteration"
		{
			attribute<float32> Total (r) := =AsList(''+SexAgeClasses/name, '+');
		}
	}
}
