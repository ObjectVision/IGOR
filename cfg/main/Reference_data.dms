Container Reference_data
: Using = "SourceData/RegionalUnits;SourceData"
, Descr = "Procedures to generate reference 2011 base maps per narrow age class, with LAU2 census data, SEDAC grids, and additional local data for NL, SK and SI" 
{
	parameter<uint8>    NumberOfIterations        := 10b,           Descr = "Number of iterations for balancing assignment.";
	unit<uint32>        Sex                       := /Classifications/Gender/woT;
	parameter<float32>  ε                         := 0.00001f;
	
	
	attribute<float32>  Ardeco           (domain) := float32(Population/Ardeco/data);
	attribute<float32>  ESTAT_M          (domain) := max_elem(float32(Population/ESTAT_Male/data  ), ε);
	attribute<float32>  ESTAT_F          (domain) := max_elem(float32(Population/ESTAT_Female/data), ε);
	attribute<float32>  ESTAT_LT15       (domain) := max_elem(float32(Population/ESTAT_LT15/data  ), ε);
	attribute<float32>  ESTAT_15_64      (domain) := max_elem(float32(Population/ESTAT_15_64/data ), ε);
	attribute<float32>  ESTAT_GE65       (domain) := max_elem(float32(Population/ESTAT_GE65/data  ), ε);
	
	attribute<float32>  ESTAT_Total_Sex  (domain) := ESTAT_M + ESTAT_F;
	attribute<float32>  ESTAT_Total_Age  (domain) := ESTAT_LT15 + ESTAT_15_64 + ESTAT_GE65;

	attribute<float32>  Share_M          (domain) := MakeDefined(ESTAT_M   / ESTAT_Total_Sex, 1f);
	attribute<float32>  Share_F          (domain) := 1f - Share_M;
	attribute<float32>  Share_LT15       (domain) := ESTAT_LT15   / ESTAT_Total_Age;
	attribute<float32>  Share_15_64      (domain) := ESTAT_15_64  / ESTAT_Total_Age;
	attribute<float32>  Share_GE65       (domain) := ESTAT_GE65   / ESTAT_Total_Age;
	
	
	container Checks
	{
		attribute<bool>     ESTAT_Sex_0_and_with_ARDECO_pop (i) := ESTAT_Total_Sex < 1f && P_i > 0f;
		attribute<bool>     ESTAT_Age_0_and_with_ARDECO_pop (i) := ESTAT_Total_Age < 1f && P_i > 0f;
		attribute<float32>  Share_M_LAU                     (r) := sum(Population/AGEGROUP5_SEX_perLAU/result/SexClass_rel == Sex/v/M ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total;
		attribute<float32>  Share_F_LAU                     (r) := 1f - Share_M_LAU;
		attribute<float32>  Share_LT15_LAU                  (r) := sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/LT15 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total;
		attribute<float32>  Share_15_64_LAU                 (r) := sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/_15_64 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total;
		attribute<float32>  Share_GE65_LAU                  (r) := sum(Population/AGEGROUP5_SEX_perLAU/result/BroadAgeClass_rel == BroadClasses/v/GE65 ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel) / Q_asr/Total;
	
	
		attribute<float32>  P_r                 (r) := sum(P_i, i/r_rel);
		attribute<float32>  Diff_Q_and_P        (r) := Q_asr/total -  P_r;
		attribute<float32>  Diff_Q_and_P_ifany0 (r) := Q_asr/total == 0f || P_r == 0f ? Diff_Q_and_P : 0f;
	}
	
	
	unit<uint32>        r                      := LAU
	{
		attribute<.> per_i (i) := per_domain;
	}
	unit<ipoint>        i                      := domain;
	attribute<float32>  P_i                (i) := Ardeco, Descr = "Population per 1km gridcell i, based on ARDECO dataset";
	
	container E_ib := 
		for_each_nedv(
			BroadClasses/name
			, 'Checks/ESTAT_Age_0_and_with_ARDECO_pop ? Checks/Share_'+BroadClasses/label+'_LAU[r/per_i] : Share_'+BroadClasses/label
			, i
			, float32
		), Descr = "Population per 1 km gridcell i, per BroadAgeGroup, based on ESTAT dataset" 
	{
		attribute<float32>  Total  (domain) := = 'add('+AsItemList(BroadClasses/name)+')';
	}
		
	container E_is := 
		for_each_nedv(
			Sex/name
			, 'Checks/ESTAT_Sex_0_and_with_ARDECO_pop ? Checks/Share_'+Sex/name+'_LAU[r/per_i] : Share_'+Sex/name
			, i
			, float32
		), Descr = "Population per 1 km gridcell i, per sex, based on ESTAT dataset" 
	{
		attribute<float32>  Total  (domain) := = 'add('+AsItemList(Sex/name)+')';
	}
		
	container Q_asr := 
		for_each_nedv(
			SexAgeClasses/name
			, 'sum(Population/AGEGROUP5_SEX_perLAU/result/SexAgeClass_rel == SexAgeClasses/v/'+SexAgeClasses/name+' ? Population/AGEGROUP5_SEX_perLAU/result/pop : 0f, Population/AGEGROUP5_SEX_perLAU/result/LAU_rel)'
			, r
			, float32
		), Descr = "Population per LAU region, split per SexAgeGroup"
	{
		attribute<float32>  Total  (r) := = 'add('+AsItemList(SexAgeClasses/name)+')';
	}
	
	// container Q_s_shares := 
		// for_each_nedv(
			// Sex/name
			// , '('+AsList('Q_asr/'+SexAgeClasses/name,'+', SexAgeClasses/first_rel)+') / Q_asr/total'
			// , r
			// , float32
		// );
	
	// container Q_b_shares := 
		// for_each_nedv(
			// BroadClasses/name
			// , '('+AsList('Q_asr/'+SexAgeClasses/name,'+', SexAgeClasses/BroadClasses_rel)+') / Q_asr/total'
			// , r
			// , float32
		// );
	
	
	
	container Iters :=
		for_each_ne(
			Iter/name
			,'Iter_T('+quote(Iter/PrevName)+')'
		), Descr = ""
	{
		container Iter_0
		{
			container B_asr := 
				for_each_nedv(
					SexAgeClasses/name
					, 'const(1f, r)'
					, r
					, float32
				), Descr = "balancing factor SexAgeGroup in region r";
		}
		
		container LastIter := =last(Iter/name)
		{
			container X_asr := 
				for_each_nedv(
					SexAgeClasses/name
					, 'sum(X_asi/'+SexAgeClasses/name+', i/r_rel)'
					, r
					, float32
				);
				
			container Diff_X_asr_Q_asr := 
				for_each_nedv(
					SexAgeClasses/name
					, 'X_asr/'+SexAgeClasses/name+' - Q_asr/'+SexAgeClasses/name+ ' * (sum(X_asi/Total, i/r_rel) / Q_asr/Total)'
					, r
					, float32
				);
				
			attribute<float32> Diff_X_i_P_i (i) := X_asi/Total - P_i, Descr = "difference between output summed pop per grid cell and input total pop.";
			
			attribute<float32>  MAPE (r) := 100f * (1f / count(X_asi/Total,  i/r_rel)[float32]) * sum( abs(P_i - X_asi/Total) / P_i,  i/r_rel), Descr = "Mean Absolute Percentage Error: a measure used to evaluate the accuracy of a forecasting model. It expresses the accuracy as a percentage. Interpretation: Lower MAPE: Indicates a better fitting model, as the errors are smaller in comparison to the actual values. Higher MAPE: Suggests a less accurate model, with larger errors relative to the actual values.";
			
			container Error_Distr_vs_Expected_Shares := 
				for_each_nedv(
					SexAgeClasses/name
					, 'abs(sum(X_asi/'+SexAgeClasses/name+' , i/r_rel) / sum(X_asi/Total, i/r_rel) - Q_asr/'+SexAgeClasses/name+' / Q_asr/Total)'
					, r
					, float32
				), Descr = "Error in distributed vs expected population shares";
				
			container Error_Abs_vs_Expected_Sizes := 
				for_each_nedv(
					SexAgeClasses/name
					, 'abs(sum(X_asi/'+SexAgeClasses/name+' , i/r_rel) - Q_asr/'+SexAgeClasses/name+')'
					, r
					, float32
				), Descr = "Error in absolute vs expected population sizes";
		}
	}
	
	unit<UInt8> Iter := cat_range(1b, NumberOfIterations + 1b)
	{
		attribute<String> name        := 'Iter_'+string(id(.));
		attribute<Bool>   IsFirstIter := id(.) == 1b;
		attribute<String> PrevName    := IsFirstIter ? 'Iter_0' : name[id(.) - min_elem( id(.), 1b)];
		attribute<String> Label       := name;
	}

	Template Iter_T
	{
		parameter<string> PrevIterName;
		container PrevIter := =PrevIterName;
		///
		
		attribute<float32> A_i (i) := ='P_i / ('+AsList('E_is/'+SexAgeClasses/Sex_rel -> name+' * E_ib/'+SexAgeClasses/BroadClasses_rel -> name+' * PrevIter/B_asr/'+SexAgeClasses/name+'[i/r_rel]', '+')+')', Descr = "balancing factor, totale populatie in cell i. Which means that it, ceteris paribus, scales with population density"; 
		
		container X_asi := 
			for_each_nedv(
				SexAgeClasses/name
				, 'E_is/'+SexAgeClasses/Sex_rel -> name+' * E_ib/'+SexAgeClasses/BroadClasses_rel -> name+' * A_i * PrevIter/B_asr/'+SexAgeClasses/name+'[i/r_rel]'
				, i
				, float32
			), Descr = "resulting population per SexAgeGroup in cell i (rebalanced by A_i from this iteration)"
		{
			attribute<float32> Total (i) := =AsList('X_asi/'+SexAgeClasses/name, '+'),
				Descr = "Sum of population per SexAgeGroup (rebalanced with A_i from this iteration); item not used in computations: debug purposes";
		}
		
		//intuition:
			// if X_asr > Q_asr -> B_asr smaller
			// if X_asr < Q_asr -> B_asr larger
			// if X_asr ~= 0 and Q_asr > 0 -> B_asr towards infinity
			
		container B_asr_raw := 
			for_each_nedv(
				SexAgeClasses/name
				, 'MakeDefined(PrevIter/B_asr/'+SexAgeClasses/name+' * Q_asr/'+SexAgeClasses/name+' / sum(X_asi/'+SexAgeClasses/name+', i/r_rel), 0f)'
				, r
				, float32
			), Descr = "Recalculated balancing factor SexAgeGroup in region r, used in next iteration"
		{
			attribute<float32> Total (r) := =AsList(''+SexAgeClasses/name, '+');
			attribute<float32> Max_elem   (r) := ='max_elem('+AsList(''+SexAgeClasses/name, ',')+', ε)';
		}
		container B_asr := 
			for_each_nedv(
				SexAgeClasses/name
				, 'B_asr_raw/'+SexAgeClasses/name + ' / B_asr_raw/Max_elem'
				, r
				, float32
			), Descr = "Recalculated balancing factor SexAgeGroup in region r, used in next iteration"
		{
			attribute<float32> Total (r) := =AsList(''+SexAgeClasses/name, '+');
		}
	}
}
