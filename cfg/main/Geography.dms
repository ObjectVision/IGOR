container Geography : using = "units"
{
	#include <ngr_layer_lea.dms>
	unit<dpoint> LambertEA_base   : SpatialReference = "EPSG:3035", DialogData = "ngr_layer_lea"
	{
		parameter<float32> ViewPortMinSize := 100f / (3600f * 4f);
		parameter<float32> PenWorldWidth   := 1f / (3600f * 4f), DialogType = "PenWorldWidth";
		parameter<float32> SymbolWorldSize := 2f / 3600f, DialogType = "SymbolWorldSize";
		parameter<float32> LabelWorldSize  := 10f / 3600f, DialogType = "LabelWorldSize";
		parameter<.>       TopLeft         := point_xy(2300000d, 5500000d, .);
	}
	unit<dpoint> LambertEA              := ='LambertEA_'+ModelParameters/StudyArea;
	unit<dpoint> LambertEA_Nederland    := range(LambertEA_base, /SourceData/RegionalUnits/Country/subset/BoundingBox/bottom_left,  /SourceData/RegionalUnits/Country/subset/BoundingBox/top_right) {parameter<LambertEA_base> geometry (polygon):= geos_union_polygon(SourceData/RegionalUnits/Country/subset/geometry_base);}

	unit<uint32> selection_polygon : nrofrows = 1, Using = "units"
	{
		container Extent_EU
		{
			parameter<float64> x_min :=  2300000d;
			parameter<float64> x_max :=  6500000d;
			parameter<float64> y_min :=  1300000d;
			parameter<float64> y_max :=  5500000d;
		}
		container Extent_Nederland
		{
			parameter<float64> x_min :=  3851000d;
			parameter<float64> x_max :=  4136000d;
			parameter<float64> y_min :=  3070000d;
			parameter<float64> y_max :=  3400000d;
		}
		
		container Extent := ='Extent_'+ModelParameters/StudyArea;
		
		parameter<LambertEA_base> top_left     := point_xy(Extent/x_min, Extent/y_max, LambertEA_base); 
		parameter<LambertEA_base> top_right    := point_xy(Extent/x_max, Extent/y_max, LambertEA_base);
		parameter<LambertEA_base> bottom_left  := point_xy(Extent/x_min, Extent/y_min, LambertEA_base);
		parameter<LambertEA_base> bottom_right := point_xy(Extent/x_max, Extent/y_min, LambertEA_base);
		
		unit<uint32> point_set : nrofrows = 5
		{
			attribute<LambertEA_base>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
			attribute<..>              sequence_rel := const(0, .);
			attribute<.>               ordinal      := id(.);
		}
		
		attribute<LambertEA_base> geometry (poly)      := points2sequence(point_set/point, point_set/sequence_rel, point_set/ordinal);
		
		unit<uint32> result := selection_polygon;
	}
 
	unit<ipoint> ProtoDomain :=
		gridset(
			range(LambertEA_base, point_xy(selection_polygon/Extent_EU/x_min, selection_polygon/Extent_EU/y_min, LambertEA_base), point_xy(selection_polygon/Extent_EU/x_max, selection_polygon/Extent_EU/y_max, LambertEA_base))// the baseunit in which the coordinates of the coordinate system are expressed
			, point_yx(-1000d, 1000d, LambertEA_base) // the size of the grid cells in both X and Y directions, expressed in the base unit;
			, LambertEA_base/TopLeft // the offset, the coordinates of the top left coordinate, expressed in the base unit;
			, ipoint                              // the value type of the resulting domain unit (in earlier versions the value type was configured as string, this is not supported anymore)
		);
		
	
	parameter<ProtoDomain> TileSize   := Point_yx(1024i, 1024i, ProtoDomain);
	parameter<ProtoDomain> TileOffset := Point_yx(   0i,    0i, ProtoDomain);

	unit<spoint>  Tile := gridset(ProtoDomain, TileSize, TileOffset, spoint)
	{
		attribute<bool>         per_ProtoDomain (ProtoDomain) := poly2grid(LambertEA/geometry, ProtoDomain);
		unit<uint64>            PD_StudyAreaSelection         := select_uint64_with_org_rel(per_ProtoDomain);
		attribute<ProtoDomain>  LB                            := min(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.]);
		attribute<ProtoDomain>  UB                            := max(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.])+point_yx(1i, 1i);
		attribute<bool>         HasStudyArea                  := any(per_ProtoDomain, ProtoDomain_rel);
		attribute<.>            ProtoDomain_rel (ProtoDomain) := mapping(ProtoDomain, .);
	}
	
	unit<uint32> StudyAreaTile := select_with_org_rel(Tile/HasStudyArea)
	{
		attribute<ProtoDomain>      LB     := Tile/LB[org_rel];
		attribute<ProtoDomain>      UB     := Tile/UB[org_rel];
		attribute<int32>            LB_X := pointcol(LB);
		attribute<int32>            LB_y := pointrow(LB);
		attribute<int32>            UB_X := pointcol(UB);
		attribute<int32>            UB_y := pointrow(UB);
	} 
	
	unit<ipoint> domain := TiledUnit(StudyAreaTile/LB, StudyAreaTile/UB)
	{
		attribute<LambertEA>                    geometry       := id(.)[LambertEA] + point_xy(0.5 * 1000d,0.5 * 1000d, LambertEA), LazyCalculated = "True", Dialogdata = "LambertEA";
		attribute<SourceData/RegionalUnits/LAU> LAU_rel        := SourceData/RegionalUnits/LAU/per_domain;
		attribute<SourceData/RegionalUnits/LAU> r_rel        :=LAU_rel;
	}
}