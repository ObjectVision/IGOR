container Geography : using = "units"
{
	#include <ngr_layer_lea.dms>
	unit<dpoint> LambertEA_base   : SpatialReference = "EPSG:3035", DialogData = "ngr_layer_lea"
	{
		parameter<float32> ViewPortMinSize := 100f / (3600f * 4f);
		parameter<float32> PenWorldWidth   := 1f / (3600f * 4f), DialogType = "PenWorldWidth";
		parameter<float32> SymbolWorldSize := 2f / 3600f, DialogType = "SymbolWorldSize";
		parameter<float32> LabelWorldSize  := 10f / 3600f, DialogType = "LabelWorldSize";
		parameter<.>       TopLeft         := point_xy(2300000d, 5500000d, .);
	}
	unit<dpoint> LambertEA              := ='impl/LambertEA_'+ModelParameters/StudyArea;

	unit<uint32> selection_polygon : nrofrows = 1, Using = "units"
	{
		container Extent_EU
		{
			parameter<float64> x_min :=  2300000d;
			parameter<float64> x_max :=  6500000d;
			parameter<float64> y_min :=  1300000d;
			parameter<float64> y_max :=  5500000d;
		}
		container Extent_Nederland
		{
			parameter<float64> x_min :=  3851000d;
			parameter<float64> x_max :=  4136000d;
			parameter<float64> y_min :=  3070000d;
			parameter<float64> y_max :=  3400000d;
		}
		
		container Extent := ='Extent_'+ModelParameters/StudyArea;
		
		parameter<LambertEA_base> top_left     := point_xy(Extent/x_min, Extent/y_max, LambertEA_base); 
		parameter<LambertEA_base> top_right    := point_xy(Extent/x_max, Extent/y_max, LambertEA_base);
		parameter<LambertEA_base> bottom_left  := point_xy(Extent/x_min, Extent/y_min, LambertEA_base);
		parameter<LambertEA_base> bottom_right := point_xy(Extent/x_max, Extent/y_min, LambertEA_base);
		
		unit<uint32> point_set : nrofrows = 5
		{
			attribute<LambertEA_base>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
			attribute<..>              sequence_rel := const(0, .);
			attribute<.>               ordinal      := id(.);
		}
		
		attribute<LambertEA_base> geometry (poly)      := points2sequence(point_set/point, point_set/sequence_rel, point_set/ordinal);
		
		unit<uint32> result := selection_polygon;
	}
	
	container impl
	{
		unit<dpoint> LambertEA_Nederland    := range(LambertEA_base, /SourceData/RegionalUnits/Country/subset/BoundingBox/bottom_left,  /SourceData/RegionalUnits/Country/subset/BoundingBox/top_right) {parameter<LambertEA_base> geometry (polygon):= geos_union_polygon(SourceData/RegionalUnits/Country/subset/geometry_base);}
		unit<dpoint> LambertEA_EU           := range(LambertEA_base, /SourceData/RegionalUnits/Country/subset/BoundingBox/bottom_left,  /SourceData/RegionalUnits/Country/subset/BoundingBox/top_right) {parameter<LambertEA_base> geometry (polygon):= geos_union_polygon(SourceData/RegionalUnits/Country/subset/geometry_base);}

		unit<ipoint> ProtoDomain_100m :=
			gridset(
				range(LambertEA_base, point_xy(selection_polygon/Extent_EU/x_min, selection_polygon/Extent_EU/y_min, LambertEA_base), point_xy(selection_polygon/Extent_EU/x_max, selection_polygon/Extent_EU/y_max, LambertEA_base))// the baseunit in which the coordinates of the coordinate system are expressed
				, point_yx(-100d, 100d, LambertEA_base) // the size of the grid cells in both X and Y directions, expressed in the base unit;
				, LambertEA_base/TopLeft // the offset, the coordinates of the top left coordinate, expressed in the base unit;
				, ipoint                              // the value type of the resulting domain unit (in earlier versions the value type was configured as string, this is not supported anymore)
			);
			
		unit<ipoint> ProtoDomain_1000m :=
			gridset(
				range(LambertEA_base, point_xy(selection_polygon/Extent_EU/x_min, selection_polygon/Extent_EU/y_min, LambertEA_base), point_xy(selection_polygon/Extent_EU/x_max, selection_polygon/Extent_EU/y_max, LambertEA_base))// the baseunit in which the coordinates of the coordinate system are expressed
				, point_yx(-1000d, 1000d, LambertEA_base) // the size of the grid cells in both X and Y directions, expressed in the base unit;
				, LambertEA_base/TopLeft // the offset, the coordinates of the top left coordinate, expressed in the base unit;
				, ipoint                              // the value type of the resulting domain unit (in earlier versions the value type was configured as string, this is not supported anymore)
			);
	
		parameter<ProtoDomain_100m>  TileSize_100m    := Point_yx(1024i, 1024i, ProtoDomain_100m);
		parameter<ProtoDomain_100m>  TileOffset_100m  := Point_yx(   0i,    0i, ProtoDomain_100m);
		parameter<ProtoDomain_1000m> TileSize_1000m   := Point_yx(1024i, 1024i, ProtoDomain_1000m);
		parameter<ProtoDomain_1000m> TileOffset_1000m := Point_yx(   0i,    0i, ProtoDomain_1000m);

		unit<spoint>  Tile_100m := gridset(ProtoDomain_100m, TileSize_100m, TileOffset_100m, spoint)
		{
			attribute<bool>              per_ProtoDomain_100m (ProtoDomain_100m) := poly2grid(LambertEA/geometry, ProtoDomain_100m);
			unit<uint64>                 PD_StudyAreaSelection                   := select_uint64_with_org_rel(per_ProtoDomain_100m);
			attribute<ProtoDomain_100m>  LB                                      := min(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.]);
			attribute<ProtoDomain_100m>  UB                                      := max(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.])+point_yx(1i, 1i);
			attribute<bool>              HasStudyArea                            := any(per_ProtoDomain_100m, ProtoDomain_100m_rel);
			attribute<.>                 ProtoDomain_100m_rel (ProtoDomain_100m) := mapping(ProtoDomain_100m, .);
		}
		unit<spoint>  Tile_1000m := gridset(ProtoDomain_1000m, TileSize_1000m, TileOffset_1000m, spoint)
		{
			attribute<bool>               per_ProtoDomain_1000m (ProtoDomain_1000m) := poly2grid(LambertEA/geometry, ProtoDomain_1000m);
			unit<uint64>                  PD_StudyAreaSelection                     := select_uint64_with_org_rel(per_ProtoDomain_1000m);
			attribute<ProtoDomain_1000m>  LB                                        := min(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.]);
			attribute<ProtoDomain_1000m>  UB                                        := max(PD_StudyAreaSelection/org_rel, PD_StudyAreaSelection/org_rel[.])+point_yx(1i, 1i);
			attribute<bool>               HasStudyArea                              := any(per_ProtoDomain_1000m, ProtoDomain_1000m_rel);
			attribute<.>                  ProtoDomain_1000m_rel (ProtoDomain_1000m) := mapping(ProtoDomain_1000m, .);
		}
		
		unit<uint32> StudyAreaTile_100m := select_with_org_rel(Tile_100m/HasStudyArea)
		{
			attribute<ProtoDomain_100m>  LB     := Tile_100m/LB[org_rel];
			attribute<ProtoDomain_100m>  UB     := Tile_100m/UB[org_rel];
			attribute<int32>             LB_X := pointcol(LB);
			attribute<int32>             LB_y := pointrow(LB);
			attribute<int32>             UB_X := pointcol(UB);
			attribute<int32>             UB_y := pointrow(UB);
		} 
		unit<uint32> StudyAreaTile_1000m := select_with_org_rel(Tile_1000m/HasStudyArea)
		{
			attribute<ProtoDomain_1000m> LB     := Tile_1000m/LB[org_rel];
			attribute<ProtoDomain_1000m> UB     := Tile_1000m/UB[org_rel];
			attribute<int32>             LB_X := pointcol(LB);
			attribute<int32>             LB_y := pointrow(LB);
			attribute<int32>             UB_X := pointcol(UB);
			attribute<int32>             UB_y := pointrow(UB);
		} 
	
		unit<ipoint> domain_100m := TiledUnit(StudyAreaTile_100m/LB, StudyAreaTile_100m/UB)
		{
			attribute<LambertEA>                    geometry          := id(.)[LambertEA] + point_xy(0.5 * 100d,0.5 * 100d, LambertEA), LazyCalculated = "True", Dialogdata = "LambertEA";
			attribute<SourceData/RegionalUnits/LAU> LAU_rel           := SourceData/RegionalUnits/LAU/per_domain_100m;
			attribute<SourceData/RegionalUnits/LAU> r_rel             := LAU_rel;
			
			attribute<bool>                         in_study_area     := AND(reference_data/p_p > 0.0f, IsDefined(r_rel));
			attribute<SourceData/RegionalUnits/LAU> r_rel_in_sa       := in_study_area ? r_rel : null_u;
			
			attribute<.>                            domain_100m_rel   := mapping(., domain_100m);
			attribute<domain_1000m>                 domain_1000m_rel  := mapping(., domain_1000m);
			
			attribute<uint64>                       NrOf100mCellsPerCell := pcount(domain_100m_rel);
			
			attribute<uint64>                       domain_key := uint64(r_rel_in_sa) * uint64(domain_1000m/NrCells) + uint64(domain_1000m_rel->Ordinal);
			attribute<domain>                       domain_rel := rlookup(domain_key, domain/values);
			
		}
		unit<ipoint> domain_1000m := TiledUnit(StudyAreaTile_1000m/LB, StudyAreaTile_1000m/UB)
		{
			parameter<int32>                       FirstCol := min(pointcol(StudyAreaTile_1000m/LB));
			parameter<int32>                       LastCol  := max(pointcol(StudyAreaTile_1000m/UB));
			parameter<uint32>                      NrCols   := 1+uint32(LastCol-FirstCol);
			parameter<int32>                       FirstRow := min(pointrow(StudyAreaTile_1000m/LB));
			parameter<int32>                       LastRow  := max(pointrow(StudyAreaTile_1000m/UB));
			parameter<uint32>                      NrRows   := 1+uint32(LastRow-FirstRow);
			parameter<uint32>                      NrCells := NrRows * NrCols;
			
			attribute<uint32>                       Ordinal := uint32(pointrow(ID(.)) -FirstRow) * NrCols + uint32(pointcol(ID(.))-FirstCol);
			
			attribute<LambertEA>                    geometry       := id(.)[LambertEA] + point_xy(0.5 * 1000d,0.5 * 1000d, LambertEA), LazyCalculated = "True", Dialogdata = "LambertEA";
			attribute<SourceData/RegionalUnits/LAU> LAU_rel        := SourceData/RegionalUnits/LAU/per_domain_1000m;
			attribute<SourceData/RegionalUnits/LAU> r_rel          := LAU_rel;
			
			// attribute<domain_100m>                  domain_100m_rel   := mapping(., domain_100m);
			attribute<.>                           domain_1000m_rel  := mapping(., domain_1000m);
			
			attribute<uint8>                       NrOf100mCellsPerCell := pcount_uint8(domain_100m/domain_1000m_rel);
			attribute<uint8>                       NrOfRegionsPerCell   := unique_count_uint8(domain_100m/r_rel_in_sa, domain_100m/domain_1000m_rel);
			attribute<bool>                        IsBorderLiner     := NrOfRegionsPerCell > 1b;
		}
	}
	
	unit<ipoint> domain_grid := ='impl/domain_'+string(ModelParameters/Gridsize)+'m';
	unit<uint32> domain := unique_uint32(impl/domain_100m/domain_key), DialogType = "Map", DialogData = "per_100mgrid"
	{
		attribute<SourceData/RegionalUnits/LAU> r_rel_in_sa := value(values / uint64(impl/domain_1000m/NrCells), SourceData/RegionalUnits/LAU);
		attribute<uint32> ordinal := uint32(values % uint64(impl/domain_1000m/NrCells));
		attribute<impl/domain_1000m> domain_1000m_rel := rlookup(ordinal, impl/domain_1000m/ordinal); // TODO: Optimize by disentangling row and col values
		
		attribute<.> per_100mgrid(impl/domain_100m) := impl/domain_100m/domain_rel;
	}
//	unit<ipoint> domain := ='impl/domain_'+string(ModelParameters/Gridsize)+'m';
	
}